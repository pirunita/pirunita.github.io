<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="3.8.5">Jekyll</generator>
  
  
  <link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2019-04-16T15:19:26+00:00</updated>
  <id>http://localhost:4000//</id>

  
    <title type="html">pirunita</title>
  

  
    <subtitle>pirunita</subtitle>
  

  
    <author>
        <name>pirunita</name>
      
      
    </author>
  

  
  
    <entry xml:lang="ko">
      
      <title type="html">STL Container</title>
      
      
      <link href="http://localhost:4000/2019/04/16/STL_container/" rel="alternate" type="text/html" title="STL Container" />
      
      <published>2019-04-16T03:00:00+00:00</published>
      <updated>2019-04-16T03:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/16/STL_container</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/16/STL_container/">&lt;p&gt;&lt;em&gt;이번부터는 cpp로 PS를 하기 위해 필요한 STL 컨테이너(docker의 컨테이너 아님)의 내부 자료구조와 동작을 간략하게 보고 PS에 필요한 것만 공부한다.&lt;/em&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;  C++ 표준 라이브러리는 특별한 컨테이너들(&lt;strong&gt;stack&lt;/strong&gt;, &lt;strong&gt;queue&lt;/strong&gt;, &lt;strong&gt;priority queue&lt;/strong&gt; 등..)을 제공하는 데, 이들에는 공통적인 특징과 동작들이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컨테이너의 공통적인 특징
    &lt;ol&gt;
      &lt;li&gt;모든 컨테이너는 “값 의미론”을 제공하기 때문에, 컨테이너에 값이 삽입될 경우 내부적으로 복사본을 생성한다. 따라서 모든 STL 컨테이너의 요소들은 복사되어질 수 있어야 한다.&lt;/li&gt;
      &lt;li&gt;컨테이너의 모든 요소들은 순서를 갖는다. 각 컨테이너는 자신의 요소를 순회할 수 있도록 반복자를 제공한다.&lt;/li&gt;
      &lt;li&gt;STL 자체는 예외를 발생시키지 않는다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너의 공통적인 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;동작&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;효과&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ContType c&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;빈 컨테이너를 생성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConType c1(c2)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;같은 타입의 컨테이너를 복사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConType c(beg, end)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;컨테이너를 생성하고 [beg, end)의 모든 원소들을 복사하여 초기화&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.~ConType()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 원소들을 지우고 메모리 해제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.size()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재 원소의 개수를 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.empty()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;컨테이너가 비어 있는지 판단(size()==0보다 빠르다)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.max_size()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;컨테이너가 가질 수 있는 최대 원소 갯수 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;== != &amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c1, c2 비교 연산자&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 = c2&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c2의 모든 원소들을 c1에 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c1.swap(c2)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c1과 c2의 데이터를 교체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swap(c1, c2)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c1과 c2의 데이터를 교체(전역함수)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.begin()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;첫 번째 원소의 반복자를 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.end()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;마지막 원소의 뒷 위치를 가리키는 반복자 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.rbegin()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;역방향의 첫 번째 원소를 가리키는 역방향 반복자 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.rend()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;역방향의 마지막 원소의 뒷 위치를 가리키는 역방향 반복자 반환&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.insert(pos, elem)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;원소의 복사본을 삽입&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.erase(beg, end)&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;[beg, end)의 모든 원소들을 제거&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.clear()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;모든 원소들을 제거, 빈 컨테이너&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c.get_allocator()&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;컨테이너의 메모리 모델을 반환&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;다른 컨테이너 원소로 초기화
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;배열의 원소로 초기화
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;33&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;표준 입력을 통하여 초기화
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istream_iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istream_iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="ProblemSolving" />
      

      
        <summary type="html">이번부터는 cpp로 PS를 하기 위해 필요한 STL 컨테이너(docker의 컨테이너 아님)의 내부 자료구조와 동작을 간략하게 보고 PS에 필요한 것만 공부한다.   C++ 표준 라이브러리는 특별한 컨테이너들(stack, queue, priority queue 등..)을 제공하는 데, 이들에는 공통적인 특징과 동작들이 있다. 컨테이너의 공통적인 특징 모든 컨테이너는 “값 의미론”을 제공하기 때문에, 컨테이너에 값이 삽입될 경우 내부적으로 복사본을 생성한다. 따라서 모든 STL 컨테이너의 요소들은 복사되어질 수 있어야 한다. 컨테이너의 모든 요소들은 순서를 갖는다. 각 컨테이너는 자신의 요소를 순회할 수 있도록 반복자를 제공한다. STL 자체는 예외를 발생시키지 않는다. 컨테이너의 공통적인 동작 동작 효과 ContType c 빈 컨테이너를 생성 ConType c1(c2) 같은 타입의 컨테이너를 복사 ConType c(beg, end) 컨테이너를 생성하고 [beg, end)의 모든 원소들을 복사하여 초기화 c.~ConType() 모든 원소들을 지우고 메모리 해제 c.size() 현재 원소의 개수를 반환 c.empty() 컨테이너가 비어 있는지 판단(size()==0보다 빠르다) c.max_size() 컨테이너가 가질 수 있는 최대 원소 갯수 반환 == != &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= c1, c2 비교 연산자 c1 = c2 c2의 모든 원소들을 c1에 할당 c1.swap(c2) c1과 c2의 데이터를 교체 swap(c1, c2) c1과 c2의 데이터를 교체(전역함수) c.begin() 첫 번째 원소의 반복자를 반환 c.end() 마지막 원소의 뒷 위치를 가리키는 반복자 반환 c.rbegin() 역방향의 첫 번째 원소를 가리키는 역방향 반복자 반환 c.rend() 역방향의 마지막 원소의 뒷 위치를 가리키는 역방향 반복자 반환 c.insert(pos, elem) 원소의 복사본을 삽입 c.erase(beg, end) [beg, end)의 모든 원소들을 제거 c.clear() 모든 원소들을 제거, 빈 컨테이너 c.get_allocator() 컨테이너의 메모리 모델을 반환 다른 컨테이너 원소로 초기화 std::list&amp;lt;int&amp;gt; l; std::vector&amp;lt;float&amp;gt; c(l.begin(), l.end()); 배열의 원소로 초기화 int array[] = {2, 3, 17, 33, 45} std::set&amp;lt;int&amp;gt; c(array, array+sizeof(array)/sizeof(array[0])) 표준 입력을 통하여 초기화 std::deque&amp;lt;int&amp;gt; c((std::istream_iterator&amp;lt;int&amp;gt;(std::cin)), (std::istream_iterator&amp;lt;int&amp;gt;()));</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">2019-04-15</title>
      
      
      <link href="http://localhost:4000/2019/04/15/Daily/" rel="alternate" type="text/html" title="2019-04-15" />
      
      <published>2019-04-15T15:00:00+00:00</published>
      <updated>2019-04-15T15:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/15/Daily</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/15/Daily/">&lt;h3&gt;헛소리&lt;/h3&gt;
&lt;p&gt;  나에게 있어 글을 쓴다는 것은 항상 어색한 것 같다. 글재주도 없지만 내가 어떤 글을 쓰고 몇 개월 후에 그 글을 다시 봤을 때 마치 타인에 의해 작성된 느낌을 지울 수 없다. 그래서 블로그를 시작한다고 매년 초에 다짐을 하고 예전에 만들어 두었던 블로그에 들어가면 그 직전 해 초에 썼던 글만이 완성되지 않은 채 나를 본다. 그렇게 잊혀지고 버려진 글은 모니터를 뚫고 나에게 이렇게 묻는 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“왜 이제서야 들어와 빨리 수정해서 네 글을 완성시켜”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;당연히 그 글은 완성할 수 없다. 1년 전의 나와 지금의 나는 좋든, 나쁘든 어느 쪽으로 변화가 일어났기 때문에 그 버려진 글을 꺼내는 것은 2명의 작성자가 하나의 글을 쓰는 것과 다를 바 없다.&lt;/p&gt;

&lt;p&gt;작성하다 만 글을 더 이상 양산하고 싶지 않기 때문에 지금 늦었고 졸리지만 뭔가 쓰고싶다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;일상 및 생각&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;올 2월 초, 미국에서 SW Maestro를 함께 했던 팀원 2명과 작년에 개발했던 프로젝트를 개량하여 창업을 하기로 뜻을 모았다. 그리고 오늘 창업경진대회 관련해서 신청서를 냈고 수정 된 모델을 학습시키는 중이다. 요즘 training을 많이 해서 GPU가 쉴 틈이 없다. 그래도 아주 디테일한 부분을 제외하면 작년보다 퀄리티는 더욱 좋아졌고 inference time도 많이 감소했다. 딥러닝 모델이 점점 똑똑해져 갔다. &lt;em&gt;그런데 나는 멍청해져 가는 것 같다.&lt;/em&gt; &lt;br /&gt;
구글 머신러닝 스터디잼으로라도 공부를 다시 해야겠다. Python3-OpenCV도 생각날 때 하는 중이다. 재밌기는 한 데, 원리를 잘 모르겠다. 고양이 책을 다시 봐야 할 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;좋은 사람을 만나고 있다. 이걸 보고 있다면 카톡 주세요.&lt;/li&gt;
  &lt;li&gt;만일을 대비해서 알고리즘을 해 두어야겠다고 생각했다. 그래서 정말 짬이 날 때 놀지만, 그냥 생각날 때 hackerrank를 본다. 내일도 하나 봐야겠다. 그래야 1일 1커밋을 할 ㅅ&lt;/li&gt;
  &lt;li&gt;Docker 좀 잘 쓰고 싶어서 휴학생도서대출 신청까지하며 보는 데 너무 재미가 없다. 서비스화 할 때 꼭 필요할 지 싶어서 조금씩 봐 두고 있다. Kubernetes는..잘 모르겠다.&lt;/li&gt;
  &lt;li&gt;최근에 갑자기 kotlin을 배워보고 싶다는 생각이 강하게 들고 있다. 여태까지 졸업프로젝트고 PS고 다 JAVA로 해결 해 왔는데 JAVA보다 더 좋은 kotlin이라니 정말로 궁금하다. ‘high performance python’이라는 책을 보고 있는데 python은 정말 재미가 없다. C++은 조금 재미있다.&lt;/li&gt;
  &lt;li&gt;쓰다보니 이게 일상인 지 프로그래밍 이야기인지 모르겠다. 언제부턴가 내 일상에 프로그래밍이 너무 가득 차 버렸다. 재밌긴 한데 공부를 안 한다. 당연히 공부를 안 하고 잘 하고 싶은 것은 욕심쟁이다. 그래도 욕심쟁이가 되고 싶다. 어쨌든 나만의 깃허브페이지에 처음으로 내가 했던 생각들을 올리니 뭔가 개운한 기분이 들
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
기는 무슨 너무 졸리니까 자야겠다.&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="Daily" />
      

      
        <summary type="html">헛소리   나에게 있어 글을 쓴다는 것은 항상 어색한 것 같다. 글재주도 없지만 내가 어떤 글을 쓰고 몇 개월 후에 그 글을 다시 봤을 때 마치 타인에 의해 작성된 느낌을 지울 수 없다. 그래서 블로그를 시작한다고 매년 초에 다짐을 하고 예전에 만들어 두었던 블로그에 들어가면 그 직전 해 초에 썼던 글만이 완성되지 않은 채 나를 본다. 그렇게 잊혀지고 버려진 글은 모니터를 뚫고 나에게 이렇게 묻는 것 같다. “왜 이제서야 들어와 빨리 수정해서 네 글을 완성시켜” 당연히 그 글은 완성할 수 없다. 1년 전의 나와 지금의 나는 좋든, 나쁘든 어느 쪽으로 변화가 일어났기 때문에 그 버려진 글을 꺼내는 것은 2명의 작성자가 하나의 글을 쓰는 것과 다를 바 없다. 작성하다 만 글을 더 이상 양산하고 싶지 않기 때문에 지금 늦었고 졸리지만 뭔가 쓰고싶다. 일상 및 생각 올 2월 초, 미국에서 SW Maestro를 함께 했던 팀원 2명과 작년에 개발했던 프로젝트를 개량하여 창업을 하기로 뜻을 모았다. 그리고 오늘 창업경진대회 관련해서 신청서를 냈고 수정 된 모델을 학습시키는 중이다. 요즘 training을 많이 해서 GPU가 쉴 틈이 없다. 그래도 아주 디테일한 부분을 제외하면 작년보다 퀄리티는 더욱 좋아졌고 inference time도 많이 감소했다. 딥러닝 모델이 점점 똑똑해져 갔다. 그런데 나는 멍청해져 가는 것 같다. 구글 머신러닝 스터디잼으로라도 공부를 다시 해야겠다. Python3-OpenCV도 생각날 때 하는 중이다. 재밌기는 한 데, 원리를 잘 모르겠다. 고양이 책을 다시 봐야 할 것 같다. 좋은 사람을 만나고 있다. 이걸 보고 있다면 카톡 주세요. 만일을 대비해서 알고리즘을 해 두어야겠다고 생각했다. 그래서 정말 짬이 날 때 놀지만, 그냥 생각날 때 hackerrank를 본다. 내일도 하나 봐야겠다. 그래야 1일 1커밋을 할 ㅅ Docker 좀 잘 쓰고 싶어서 휴학생도서대출 신청까지하며 보는 데 너무 재미가 없다. 서비스화 할 때 꼭 필요할 지 싶어서 조금씩 봐 두고 있다. Kubernetes는..잘 모르겠다. 최근에 갑자기 kotlin을 배워보고 싶다는 생각이 강하게 들고 있다. 여태까지 졸업프로젝트고 PS고 다 JAVA로 해결 해 왔는데 JAVA보다 더 좋은 kotlin이라니 정말로 궁금하다. ‘high performance python’이라는 책을 보고 있는데 python은 정말 재미가 없다. C++은 조금 재미있다. 쓰다보니 이게 일상인 지 프로그래밍 이야기인지 모르겠다. 언제부턴가 내 일상에 프로그래밍이 너무 가득 차 버렸다. 재밌긴 한데 공부를 안 한다. 당연히 공부를 안 하고 잘 하고 싶은 것은 욕심쟁이다. 그래도 욕심쟁이가 되고 싶다. 어쨌든 나만의 깃허브페이지에 처음으로 내가 했던 생각들을 올리니 뭔가 개운한 기분이 들 기는 무슨 너무 졸리니까 자야겠다.</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">Binary Search</title>
      
      
      <link href="http://localhost:4000/2019/04/15/Binary_Search/" rel="alternate" type="text/html" title="Binary Search" />
      
      <published>2019-04-15T14:00:00+00:00</published>
      <updated>2019-04-15T14:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/15/Binary_Search</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/15/Binary_Search/">&lt;p&gt;&lt;em&gt;1일 1커밋을 목표로 했지만 시간이 없으니 예전에 정리해 둔 binary search를 올리려고 한다.&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;원래 JAVA로 Problem Solving을 했지만 진짜 코드가 길고 귀찮아서 역시 언어를 바꿔야겠다는 생각에&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;빠르게 C++ 기초를 읽고 hackerrank로 PS를 시작하게 되는데…&lt;/em&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/algorithm/lower_bound/&quot;&gt;http://www.cplusplus.com/reference/algorithm/lower_bound/&lt;/a&gt;
&lt;br /&gt;
  Binary Search(이분 탐색)은 정렬되어 있는 배열에서 우리가 찾고 싶은 값을 빠르게 찾기 위한 탐색 방법이다. 이분 탐색인 것은 탐색 범위를 계속 반으로 줄여나가며 찾기 때문이다.&lt;br /&gt;
  이 때 우리가 찾고싶은 값들과 관련해서 두 가지의 위치로 나타낼 수 있다. &lt;strong&gt;lower bound&lt;/strong&gt;, &lt;strong&gt;upper bound&lt;/strong&gt;이며 STL에도 잘 구현되어 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lower bound : Lower bound는 우리가 찾고 싶은 값 &lt;strong&gt;이상(포함)&lt;/strong&gt;이 처음으로 나오는 위치이다.&lt;/li&gt;
  &lt;li&gt;Upper bound : Upper bound는 우리가 찾고 싶은 값 &lt;strong&gt;초과&lt;/strong&gt;가 처음으로 나오는 위치이다.&lt;br /&gt;
예시를 한 번 보자
&lt;br /&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1, 2, 3, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 때 우리가 찾고 싶은 값이 3이라면 &lt;strong&gt;Lower bound&lt;/strong&gt;는 처음 등장하는 3 이상인 값인 &lt;strong&gt;3번째 위치&lt;/strong&gt;의 3이고&lt;br /&gt;
&lt;strong&gt;Upper bound&lt;/strong&gt;는 처음 등장하는 3보다 큰 값인 &lt;strong&gt;5번째 위치&lt;/strong&gt;의 4이다.
&lt;br /&gt;&lt;br /&gt;
개념을 알았으니 구현은 생략하고 STL을 사용 해 본다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Example&lt;/h4&gt;
&lt;p&gt;(다음은 cpp reference document에 있던 예제이다.)&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// lower_bound/upper_bound example&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;     // std::cout
#include &amp;lt;algorithm&amp;gt;    // std::lower_bound, std::upper_bound, std::sort
#include &amp;lt;vector&amp;gt;       // std::vector
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 10 20 30 30 20 10 10 20&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 10 10 10 20 20 20 30 30&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower_bound&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper_bound&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;lower_bound at position &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;upper_bound at position &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lower_bound at position 3
upper_bound at position 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;low는 20 이상이 처음 나오는 위치이기 때문에 4번째 즉 v[3]에 위치한 20이고,&lt;br /&gt;
up 은 20 초과가 처음 나오는 위치이기 때문에 7번째 즉 v[6]에 위치한 30이다.&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="ProblemSolving" />
      

      
        <summary type="html">1일 1커밋을 목표로 했지만 시간이 없으니 예전에 정리해 둔 binary search를 올리려고 한다. 원래 JAVA로 Problem Solving을 했지만 진짜 코드가 길고 귀찮아서 역시 언어를 바꿔야겠다는 생각에 빠르게 C++ 기초를 읽고 hackerrank로 PS를 시작하게 되는데… http://www.cplusplus.com/reference/algorithm/lower_bound/   Binary Search(이분 탐색)은 정렬되어 있는 배열에서 우리가 찾고 싶은 값을 빠르게 찾기 위한 탐색 방법이다. 이분 탐색인 것은 탐색 범위를 계속 반으로 줄여나가며 찾기 때문이다.   이 때 우리가 찾고싶은 값들과 관련해서 두 가지의 위치로 나타낼 수 있다. lower bound, upper bound이며 STL에도 잘 구현되어 있다. Lower bound : Lower bound는 우리가 찾고 싶은 값 이상(포함)이 처음으로 나오는 위치이다. Upper bound : Upper bound는 우리가 찾고 싶은 값 초과가 처음으로 나오는 위치이다. 예시를 한 번 보자 [1, 2, 3, 3, 4, 5] 이 때 우리가 찾고 싶은 값이 3이라면 Lower bound는 처음 등장하는 3 이상인 값인 3번째 위치의 3이고 Upper bound는 처음 등장하는 3보다 큰 값인 5번째 위치의 4이다. 개념을 알았으니 구현은 생략하고 STL을 사용 해 본다. Example (다음은 cpp reference document에 있던 예제이다.) // lower_bound/upper_bound example #include &amp;lt;iostream&amp;gt; // std::cout #include &amp;lt;algorithm&amp;gt; // std::lower_bound, std::upper_bound, std::sort #include &amp;lt;vector&amp;gt; // std::vector int main () { int myints[] = {10,20,30,30,20,10,10,20}; std::vector&amp;lt;int&amp;gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&amp;lt;int&amp;gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); up= std::upper_bound (v.begin(), v.end(), 20); std::cout &amp;lt;&amp;lt; &quot;lower_bound at position &quot; &amp;lt;&amp;lt; (low- v.begin()) &amp;lt;&amp;lt; '\n'; std::cout &amp;lt;&amp;lt; &quot;upper_bound at position &quot; &amp;lt;&amp;lt; (up - v.begin()) &amp;lt;&amp;lt; '\n'; return 0; } Output: lower_bound at position 3 upper_bound at position 6 low는 20 이상이 처음 나오는 위치이기 때문에 4번째 즉 v[3]에 위치한 20이고, up 은 20 초과가 처음 나오는 위치이기 때문에 7번째 즉 v[6]에 위치한 30이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">Docker 기초 및 command 정리</title>
      
      
      <link href="http://localhost:4000/2019/04/10/Docker_basic_command/" rel="alternate" type="text/html" title="Docker 기초 및 command 정리" />
      
      <published>2019-04-10T15:00:00+00:00</published>
      <updated>2019-04-10T15:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/10/Docker_basic_command</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/10/Docker_basic_command/">&lt;h2&gt;Docker basic &amp;amp; Command&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3&gt;왜 Docker를 사용하는가?&lt;/h3&gt;
&lt;p&gt;  Containers는 하나의 서로 다른 프로그램이나 프로세스를 고립시키는 방법이며, 프로그램이 오류없이 빠르게 deploy를 시킬 수 있게한다. 또한 application을 호스트 컴퓨터에 직접 설치할 때보다 높은 유연성을 제공하며 가상머신과 비교했을 때 CPU, 메모리, 디스크 공간과 같은 시스템 리소스를 적게 소비한다.&lt;/p&gt;

&lt;h3&gt;Docker 이미지와 컨테이너&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Containerization: Application을 하나의 컨테이너 단위로 구동하는 데 필요한 모든 구성 요소(라이브러리, 설정 파일, 실행 파일 등..)를 하나로 묶는다. 이러한 단위를 &lt;strong&gt;image&lt;/strong&gt;라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Image: 도커가 설치되고 구동할 준비를 하고 있는 로컬 파일 시스템, 또는 repository에 저장된 하나의 정적인 단위.
    &lt;ul&gt;
      &lt;li&gt;Image를 파일시스템에 저장하면 tarb4all(tar.gz) 파일 형태로 저장된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Container: Docker Image를 구동한 instance를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Docker command&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Docker 구성 요소에 대한 정보 조회
    &lt;ul&gt;
      &lt;li&gt;docker version: Docker의 버전 정보&lt;/li&gt;
      &lt;li&gt;docker info: Docker를 구동하는 시스템에 대한 정보&lt;/li&gt;
      &lt;li&gt;docker comand: Docker command에서 사용할 수 있는 subcommand와 option을 보여준다.&lt;/li&gt;
      &lt;li&gt;docker history: &lt;strong&gt;Image&lt;/strong&gt;에 대한 히스토리 정보를 보여준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 중인 Container 다루기
    &lt;ul&gt;
      &lt;li&gt;docker ps: 현재 실행 중인 container list를 보여준다.
        &lt;ul&gt;
          &lt;li&gt;-a: 모든 container의 상태를 보여준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker attach: 실행 중인 cantainer에 다른 command를 붙인다.&lt;/li&gt;
      &lt;li&gt;docker exec: 현재 실행 중인 컨테이너에서 command를 실행한다.&lt;/li&gt;
      &lt;li&gt;docker inspect: container의 metadata를 본다.&lt;/li&gt;
      &lt;li&gt;docker cp: container에 있는 파일을 호스트 시스템으로 복사&lt;/li&gt;
      &lt;li&gt;docker diff: container를 구동한 후에 컨테이너의 파일시스템에서 변경된 사항을 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Image 다루기
    &lt;ul&gt;
      &lt;li&gt;docker images: 시스템에 있는 image 리스트를 보여준다.&lt;/li&gt;
      &lt;li&gt;docker run: image를 실행한다.
        &lt;ul&gt;
          &lt;li&gt;-rm: 프로세스가 종료되면 컨테이너 자동 삭제&lt;/li&gt;
          &lt;li&gt;-it: container 내부에 들어가기 위해 bash 키보드 입력 설정 추가&lt;/li&gt;
          &lt;li&gt;/bin/bash: bash쉘 실행
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm -it &amp;lt;image_name&amp;gt; /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker pull: 레지스트리에서 image를 가져온다.
        &lt;ul&gt;
          &lt;li&gt;docker pull ubuntu:latest&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker push: 레지스트리에 image를 올린다.&lt;/li&gt;
      &lt;li&gt;docker load: 로컬 시스템에 tarball 형태로 존재하는 image를 불러온다.&lt;/li&gt;
      &lt;li&gt;docker export: container의 파일시스템을 로컬 시스템에 tarball 형태로 내보낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker 레지스트리 다루기
    &lt;ul&gt;
      &lt;li&gt;docker search: 레지스트리에서 이미지를 검색한다.(자신의 계정에 image를 올리거나 가져올 때)&lt;/li&gt;
      &lt;li&gt;docker login: 도커 허브 레지스트리 로그인&lt;/li&gt;
      &lt;li&gt;docker logout: 도커 허브 레지스트리 로그아웃&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존 이미지 수정하기
    &lt;ul&gt;
      &lt;li&gt;docker tag: image에 이름을 붙인다.&lt;/li&gt;
      &lt;li&gt;docker rename: image의 이름을 변경한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;container 상태 변경하기
    &lt;ul&gt;
      &lt;li&gt;docker pause: 실행 중인 container 일시 정지&lt;/li&gt;
      &lt;li&gt;docker unpause: 일시 정지한 이미지를 다시 시작&lt;/li&gt;
      &lt;li&gt;docker kill: container에게 kill 신호를 보냄&lt;/li&gt;
      &lt;li&gt;docker restart: container를 멈췄다가 다시 시작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;docker 상태 관찰하기
    &lt;ul&gt;
      &lt;li&gt;docker events: 도커 서버에서 발생한 이벤트 확인&lt;/li&gt;
      &lt;li&gt;docker top: container의 프로세스 현황 확인&lt;/li&gt;
      &lt;li&gt;docker logs: container에서 생성한 로그 메시지 확인&lt;/li&gt;
      &lt;li&gt;docker stats: container에 대한 CPU 및 메모리 사용량 확인&lt;/li&gt;
      &lt;li&gt;docker wait: container가 멈출 때까지 관찰하며 container의 종료 코드를 화면에 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Image나 container 생성하기
    &lt;ul&gt;
      &lt;li&gt;docker build: Image를 새로 생성
        &lt;ul&gt;
          &lt;li&gt;-t: image name을 붙임&lt;/li&gt;
          &lt;li&gt;dockerfile이 같은 폴더 내에 위치할 경우
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t &amp;lt;image_name&amp;gt; ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker rmi: Image를 제거
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rmi &amp;lt;image_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;none으로 지정된 이름을 제거하기 위해
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rmi $(docker images -a|grep &quot;&amp;lt;none&amp;gt;&quot;|awk '{print $3}')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자주 사용하는 옵션
    &lt;ul&gt;
      &lt;li&gt;d: detached mode, 백그라운드 모드&lt;/li&gt;
      &lt;li&gt;p: 호스트와 container의 포트를 연결(포워딩)&lt;/li&gt;
      &lt;li&gt;v: 호스트와 container의 디렉토리를 연결(마운트)&lt;/li&gt;
      &lt;li&gt;e: container 내에서 사용 할 환경변수 설정&lt;/li&gt;
      &lt;li&gt;name: container 이름 설정&lt;/li&gt;
      &lt;li&gt;rm: 프로세스 종료 시 container 자동 삭제&lt;/li&gt;
      &lt;li&gt;it: 터미널 입력을 위한 옵션&lt;/li&gt;
      &lt;li&gt;link: container 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="DevOps" />
      

      
        <summary type="html">Docker basic &amp;amp; Command 왜 Docker를 사용하는가?   Containers는 하나의 서로 다른 프로그램이나 프로세스를 고립시키는 방법이며, 프로그램이 오류없이 빠르게 deploy를 시킬 수 있게한다. 또한 application을 호스트 컴퓨터에 직접 설치할 때보다 높은 유연성을 제공하며 가상머신과 비교했을 때 CPU, 메모리, 디스크 공간과 같은 시스템 리소스를 적게 소비한다. Docker 이미지와 컨테이너 Containerization: Application을 하나의 컨테이너 단위로 구동하는 데 필요한 모든 구성 요소(라이브러리, 설정 파일, 실행 파일 등..)를 하나로 묶는다. 이러한 단위를 image라고 한다. Image: 도커가 설치되고 구동할 준비를 하고 있는 로컬 파일 시스템, 또는 repository에 저장된 하나의 정적인 단위. Image를 파일시스템에 저장하면 tarb4all(tar.gz) 파일 형태로 저장된다. Container: Docker Image를 구동한 instance를 의미한다. Docker command Docker 구성 요소에 대한 정보 조회 docker version: Docker의 버전 정보 docker info: Docker를 구동하는 시스템에 대한 정보 docker comand: Docker command에서 사용할 수 있는 subcommand와 option을 보여준다. docker history: Image에 대한 히스토리 정보를 보여준다. 실행 중인 Container 다루기 docker ps: 현재 실행 중인 container list를 보여준다. -a: 모든 container의 상태를 보여준다. docker attach: 실행 중인 cantainer에 다른 command를 붙인다. docker exec: 현재 실행 중인 컨테이너에서 command를 실행한다. docker inspect: container의 metadata를 본다. docker cp: container에 있는 파일을 호스트 시스템으로 복사 docker diff: container를 구동한 후에 컨테이너의 파일시스템에서 변경된 사항을 확인 Image 다루기 docker images: 시스템에 있는 image 리스트를 보여준다. docker run: image를 실행한다. -rm: 프로세스가 종료되면 컨테이너 자동 삭제 -it: container 내부에 들어가기 위해 bash 키보드 입력 설정 추가 /bin/bash: bash쉘 실행 docker run --rm -it &amp;lt;image_name&amp;gt; /bin/bash docker pull: 레지스트리에서 image를 가져온다. docker pull ubuntu:latest docker push: 레지스트리에 image를 올린다. docker load: 로컬 시스템에 tarball 형태로 존재하는 image를 불러온다. docker export: container의 파일시스템을 로컬 시스템에 tarball 형태로 내보낸다. Docker 레지스트리 다루기 docker search: 레지스트리에서 이미지를 검색한다.(자신의 계정에 image를 올리거나 가져올 때) docker login: 도커 허브 레지스트리 로그인 docker logout: 도커 허브 레지스트리 로그아웃 기존 이미지 수정하기 docker tag: image에 이름을 붙인다. docker rename: image의 이름을 변경한다. container 상태 변경하기 docker pause: 실행 중인 container 일시 정지 docker unpause: 일시 정지한 이미지를 다시 시작 docker kill: container에게 kill 신호를 보냄 docker restart: container를 멈췄다가 다시 시작 docker 상태 관찰하기 docker events: 도커 서버에서 발생한 이벤트 확인 docker top: container의 프로세스 현황 확인 docker logs: container에서 생성한 로그 메시지 확인 docker stats: container에 대한 CPU 및 메모리 사용량 확인 docker wait: container가 멈출 때까지 관찰하며 container의 종료 코드를 화면에 표시 Image나 container 생성하기 docker build: Image를 새로 생성 -t: image name을 붙임 dockerfile이 같은 폴더 내에 위치할 경우 docker build -t &amp;lt;image_name&amp;gt; ./ docker rmi: Image를 제거 docker rmi &amp;lt;image_name&amp;gt; none으로 지정된 이름을 제거하기 위해 docker rmi $(docker images -a|grep &quot;&amp;lt;none&amp;gt;&quot;|awk '{print $3}') 자주 사용하는 옵션 d: detached mode, 백그라운드 모드 p: 호스트와 container의 포트를 연결(포워딩) v: 호스트와 container의 디렉토리를 연결(마운트) e: container 내에서 사용 할 환경변수 설정 name: container 이름 설정 rm: 프로세스 종료 시 container 자동 삭제 it: 터미널 입력을 위한 옵션 link: container 연결</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">딥러닝 공부 기초</title>
      
      
      <link href="http://localhost:4000/2018/12/23/DeepLearningBasic/" rel="alternate" type="text/html" title="딥러닝 공부 기초" />
      
      <published>2018-12-23T14:00:00+00:00</published>
      <updated>2018-12-23T14:00:00+00:00</updated>
      <id>http://localhost:4000/2018/12/23/DeepLearningBasic</id>
      <content type="html" xml:base="http://localhost:4000/2018/12/23/DeepLearningBasic/">&lt;h4&gt;Deep Learning from Scratch(밑바닥부터 시작하는 딥러닝), Saito koki, 한빛미디어&lt;/h4&gt;
&lt;hr /&gt;

&lt;p&gt;Chapter 1, 2 : 생략&lt;br /&gt;
Chapter 3 : &lt;a href=&quot;https://github.com/pirunita/DeepLearningBasic/blob/master/Chapter%203.%20Neural%20Network.ipynb&quot;&gt;[click]&lt;/a&gt;&lt;br /&gt;
Chapter 4 : &lt;a href=&quot;https://github.com/pirunita/DeepLearningBasic/blob/master/Chapter%204.%20Neural%20Network%20Training.ipynb&quot;&gt;[click]&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="DeepLearning" />
      

      
        <summary type="html">Deep Learning from Scratch(밑바닥부터 시작하는 딥러닝), Saito koki, 한빛미디어 Chapter 1, 2 : 생략 Chapter 3 : [click] Chapter 4 : [click]</summary>
      

      
      
    </entry>
  
  
</feed>
