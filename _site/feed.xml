<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="3.8.5">Jekyll</generator>
  
  
  <link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2019-04-15T15:14:11+00:00</updated>
  <id>http://localhost:4000//</id>

  
    <title type="html">pirunita</title>
  

  
    <subtitle>pirunita</subtitle>
  

  
    <author>
        <name>pirunita</name>
      
      
    </author>
  

  
  
    <entry xml:lang="ko">
      
      <title type="html">Binary Search</title>
      
      
      <link href="http://localhost:4000/2019/04/15/Binary_Search/" rel="alternate" type="text/html" title="Binary Search" />
      
      <published>2019-04-15T14:00:00+00:00</published>
      <updated>2019-04-15T14:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/15/Binary_Search</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/15/Binary_Search/">&lt;p&gt;&lt;em&gt;1일 1커밋을 목표로 했지만 시간이 없으니 예전에 정리해 둔 binary search를 올리려고 한다.&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;원래 JAVA로 Problem Solving을 했지만 진짜 코드가 길고 귀찮아서 역시 언어를 바꿔야겠다는 생각에&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;빠르게 C++ 기초를 읽고 hackerrank로 PS를 시작하게 되는데…&lt;/em&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/algorithm/lower_bound/&quot;&gt;http://www.cplusplus.com/reference/algorithm/lower_bound/&lt;/a&gt;
&lt;br /&gt;
  Binary Search(이분 탐색)은 정렬되어 있는 배열에서 우리가 찾고 싶은 값을 빠르게 찾기 위한 탐색 방법이다. 이분 탐색인 것은 탐색 범위를 계속 반으로 줄여나가며 찾기 때문이다.&lt;br /&gt;
  이 때 우리가 찾고싶은 값들과 관련해서 두 가지의 위치로 나타낼 수 있다. &lt;strong&gt;lower bound&lt;/strong&gt;, &lt;strong&gt;upper bound&lt;/strong&gt;이며 STL에도 잘 구현되어 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Lower bound : Lower bound는 우리가 찾고 싶은 값 &lt;strong&gt;이상(포함)&lt;/strong&gt;이 처음으로 나오는 위치이다.&lt;/li&gt;
  &lt;li&gt;Upper bound : Upper bound는 우리가 찾고 싶은 값 &lt;strong&gt;초과&lt;/strong&gt;가 처음으로 나오는 위치이다.&lt;br /&gt;
예시를 한 번 보자
&lt;br /&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1, 2, 3, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;이 때 우리가 찾고 싶은 값이 3이라면 &lt;strong&gt;Lower bound&lt;/strong&gt;는 처음 등장하는 3 이상인 값인 &lt;strong&gt;3번째 위치&lt;/strong&gt;의 3이고&lt;br /&gt;
&lt;strong&gt;Upper bound&lt;/strong&gt;는 처음 등장하는 3보다 큰 값인 &lt;strong&gt;5번째 위치&lt;/strong&gt;의 4이다.
&lt;br /&gt;&lt;br /&gt;
개념을 알았으니 구현은 생략하고 STL을 사용 해 본다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Example&lt;/h4&gt;
&lt;p&gt;(다음은 cpp reference document에 있던 예제이다.)&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// lower_bound/upper_bound example&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;     // std::cout
#include &amp;lt;algorithm&amp;gt;    // std::lower_bound, std::upper_bound, std::sort
#include &amp;lt;vector&amp;gt;       // std::vector
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myints&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 10 20 30 30 20 10 10 20&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 10 10 10 20 20 20 30 30&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lower_bound&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;upper_bound&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;lower_bound at position &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;upper_bound at position &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;up&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lower_bound at position 3
upper_bound at position 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;low는 20 이상이 처음 나오는 위치이기 때문에 4번째 즉 v[3]에 위치한 20이고,&lt;br /&gt;
up 은 20 초과가 처음 나오는 위치이기 때문에 7번째 즉 v[6]에 위치한 30이다.&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="ProblemSolving" />
      

      
        <summary type="html">1일 1커밋을 목표로 했지만 시간이 없으니 예전에 정리해 둔 binary search를 올리려고 한다. 원래 JAVA로 Problem Solving을 했지만 진짜 코드가 길고 귀찮아서 역시 언어를 바꿔야겠다는 생각에 빠르게 C++ 기초를 읽고 hackerrank로 PS를 시작하게 되는데… http://www.cplusplus.com/reference/algorithm/lower_bound/   Binary Search(이분 탐색)은 정렬되어 있는 배열에서 우리가 찾고 싶은 값을 빠르게 찾기 위한 탐색 방법이다. 이분 탐색인 것은 탐색 범위를 계속 반으로 줄여나가며 찾기 때문이다.   이 때 우리가 찾고싶은 값들과 관련해서 두 가지의 위치로 나타낼 수 있다. lower bound, upper bound이며 STL에도 잘 구현되어 있다. Lower bound : Lower bound는 우리가 찾고 싶은 값 이상(포함)이 처음으로 나오는 위치이다. Upper bound : Upper bound는 우리가 찾고 싶은 값 초과가 처음으로 나오는 위치이다. 예시를 한 번 보자 [1, 2, 3, 3, 4, 5] 이 때 우리가 찾고 싶은 값이 3이라면 Lower bound는 처음 등장하는 3 이상인 값인 3번째 위치의 3이고 Upper bound는 처음 등장하는 3보다 큰 값인 5번째 위치의 4이다. 개념을 알았으니 구현은 생략하고 STL을 사용 해 본다. Example (다음은 cpp reference document에 있던 예제이다.) // lower_bound/upper_bound example #include &amp;lt;iostream&amp;gt; // std::cout #include &amp;lt;algorithm&amp;gt; // std::lower_bound, std::upper_bound, std::sort #include &amp;lt;vector&amp;gt; // std::vector int main () { int myints[] = {10,20,30,30,20,10,10,20}; std::vector&amp;lt;int&amp;gt; v(myints,myints+8); // 10 20 30 30 20 10 10 20 std::sort (v.begin(), v.end()); // 10 10 10 20 20 20 30 30 std::vector&amp;lt;int&amp;gt;::iterator low,up; low=std::lower_bound (v.begin(), v.end(), 20); up= std::upper_bound (v.begin(), v.end(), 20); std::cout &amp;lt;&amp;lt; &quot;lower_bound at position &quot; &amp;lt;&amp;lt; (low- v.begin()) &amp;lt;&amp;lt; '\n'; std::cout &amp;lt;&amp;lt; &quot;upper_bound at position &quot; &amp;lt;&amp;lt; (up - v.begin()) &amp;lt;&amp;lt; '\n'; return 0; } Output: lower_bound at position 3 upper_bound at position 6 low는 20 이상이 처음 나오는 위치이기 때문에 4번째 즉 v[3]에 위치한 20이고, up 은 20 초과가 처음 나오는 위치이기 때문에 7번째 즉 v[6]에 위치한 30이다.</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">Docker 기초 및 command 정리</title>
      
      
      <link href="http://localhost:4000/2019/04/10/Docker_basic_command/" rel="alternate" type="text/html" title="Docker 기초 및 command 정리" />
      
      <published>2019-04-10T15:00:00+00:00</published>
      <updated>2019-04-10T15:00:00+00:00</updated>
      <id>http://localhost:4000/2019/04/10/Docker_basic_command</id>
      <content type="html" xml:base="http://localhost:4000/2019/04/10/Docker_basic_command/">&lt;h2&gt;Docker basic &amp;amp; Command&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3&gt;왜 Docker를 사용하는가?&lt;/h3&gt;
&lt;p&gt;  Containers는 하나의 서로 다른 프로그램이나 프로세스를 고립시키는 방법이며, 프로그램이 오류없이 빠르게 deploy를 시킬 수 있게한다. 또한 application을 호스트 컴퓨터에 직접 설치할 때보다 높은 유연성을 제공하며 가상머신과 비교했을 때 CPU, 메모리, 디스크 공간과 같은 시스템 리소스를 적게 소비한다.&lt;/p&gt;

&lt;h3&gt;Docker 이미지와 컨테이너&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Containerization: Application을 하나의 컨테이너 단위로 구동하는 데 필요한 모든 구성 요소(라이브러리, 설정 파일, 실행 파일 등..)를 하나로 묶는다. 이러한 단위를 &lt;strong&gt;image&lt;/strong&gt;라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Image: 도커가 설치되고 구동할 준비를 하고 있는 로컬 파일 시스템, 또는 repository에 저장된 하나의 정적인 단위.
    &lt;ul&gt;
      &lt;li&gt;Image를 파일시스템에 저장하면 tarb4all(tar.gz) 파일 형태로 저장된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Container: Docker Image를 구동한 instance를 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Docker command&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Docker 구성 요소에 대한 정보 조회
    &lt;ul&gt;
      &lt;li&gt;docker version: Docker의 버전 정보&lt;/li&gt;
      &lt;li&gt;docker info: Docker를 구동하는 시스템에 대한 정보&lt;/li&gt;
      &lt;li&gt;docker comand: Docker command에서 사용할 수 있는 subcommand와 option을 보여준다.&lt;/li&gt;
      &lt;li&gt;docker history: &lt;strong&gt;Image&lt;/strong&gt;에 대한 히스토리 정보를 보여준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 중인 Container 다루기
    &lt;ul&gt;
      &lt;li&gt;docker ps: 현재 실행 중인 container list를 보여준다.
        &lt;ul&gt;
          &lt;li&gt;-a: 모든 container의 상태를 보여준다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker attach: 실행 중인 cantainer에 다른 command를 붙인다.&lt;/li&gt;
      &lt;li&gt;docker exec: 현재 실행 중인 컨테이너에서 command를 실행한다.&lt;/li&gt;
      &lt;li&gt;docker inspect: container의 metadata를 본다.&lt;/li&gt;
      &lt;li&gt;docker cp: container에 있는 파일을 호스트 시스템으로 복사&lt;/li&gt;
      &lt;li&gt;docker diff: container를 구동한 후에 컨테이너의 파일시스템에서 변경된 사항을 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Image 다루기
    &lt;ul&gt;
      &lt;li&gt;docker images: 시스템에 있는 image 리스트를 보여준다.&lt;/li&gt;
      &lt;li&gt;docker run: image를 실행한다.
        &lt;ul&gt;
          &lt;li&gt;-rm: 프로세스가 종료되면 컨테이너 자동 삭제&lt;/li&gt;
          &lt;li&gt;-it: container 내부에 들어가기 위해 bash 키보드 입력 설정 추가&lt;/li&gt;
          &lt;li&gt;/bin/bash: bash쉘 실행
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm -it &amp;lt;image_name&amp;gt; /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker pull: 레지스트리에서 image를 가져온다.
        &lt;ul&gt;
          &lt;li&gt;docker pull ubuntu:latest&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker push: 레지스트리에 image를 올린다.&lt;/li&gt;
      &lt;li&gt;docker load: 로컬 시스템에 tarball 형태로 존재하는 image를 불러온다.&lt;/li&gt;
      &lt;li&gt;docker export: container의 파일시스템을 로컬 시스템에 tarball 형태로 내보낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker 레지스트리 다루기
    &lt;ul&gt;
      &lt;li&gt;docker search: 레지스트리에서 이미지를 검색한다.(자신의 계정에 image를 올리거나 가져올 때)&lt;/li&gt;
      &lt;li&gt;docker login: 도커 허브 레지스트리 로그인&lt;/li&gt;
      &lt;li&gt;docker logout: 도커 허브 레지스트리 로그아웃&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존 이미지 수정하기
    &lt;ul&gt;
      &lt;li&gt;docker tag: image에 이름을 붙인다.&lt;/li&gt;
      &lt;li&gt;docker rename: image의 이름을 변경한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;container 상태 변경하기
    &lt;ul&gt;
      &lt;li&gt;docker pause: 실행 중인 container 일시 정지&lt;/li&gt;
      &lt;li&gt;docker unpause: 일시 정지한 이미지를 다시 시작&lt;/li&gt;
      &lt;li&gt;docker kill: container에게 kill 신호를 보냄&lt;/li&gt;
      &lt;li&gt;docker restart: container를 멈췄다가 다시 시작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;docker 상태 관찰하기
    &lt;ul&gt;
      &lt;li&gt;docker events: 도커 서버에서 발생한 이벤트 확인&lt;/li&gt;
      &lt;li&gt;docker top: container의 프로세스 현황 확인&lt;/li&gt;
      &lt;li&gt;docker logs: container에서 생성한 로그 메시지 확인&lt;/li&gt;
      &lt;li&gt;docker stats: container에 대한 CPU 및 메모리 사용량 확인&lt;/li&gt;
      &lt;li&gt;docker wait: container가 멈출 때까지 관찰하며 container의 종료 코드를 화면에 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Image나 container 생성하기
    &lt;ul&gt;
      &lt;li&gt;docker build: Image를 새로 생성
        &lt;ul&gt;
          &lt;li&gt;-t: image name을 붙임&lt;/li&gt;
          &lt;li&gt;dockerfile이 같은 폴더 내에 위치할 경우
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t &amp;lt;image_name&amp;gt; ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;docker rmi: Image를 제거
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rmi &amp;lt;image_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;ul&gt;
          &lt;li&gt;none으로 지정된 이름을 제거하기 위해
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rmi $(docker images -a|grep &quot;&amp;lt;none&amp;gt;&quot;|awk '{print $3}')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자주 사용하는 옵션
    &lt;ul&gt;
      &lt;li&gt;d: detached mode, 백그라운드 모드&lt;/li&gt;
      &lt;li&gt;p: 호스트와 container의 포트를 연결(포워딩)&lt;/li&gt;
      &lt;li&gt;v: 호스트와 container의 디렉토리를 연결(마운트)&lt;/li&gt;
      &lt;li&gt;e: container 내에서 사용 할 환경변수 설정&lt;/li&gt;
      &lt;li&gt;name: container 이름 설정&lt;/li&gt;
      &lt;li&gt;rm: 프로세스 종료 시 container 자동 삭제&lt;/li&gt;
      &lt;li&gt;it: 터미널 입력을 위한 옵션&lt;/li&gt;
      &lt;li&gt;link: container 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="DevOps" />
      

      
        <summary type="html">Docker basic &amp;amp; Command 왜 Docker를 사용하는가?   Containers는 하나의 서로 다른 프로그램이나 프로세스를 고립시키는 방법이며, 프로그램이 오류없이 빠르게 deploy를 시킬 수 있게한다. 또한 application을 호스트 컴퓨터에 직접 설치할 때보다 높은 유연성을 제공하며 가상머신과 비교했을 때 CPU, 메모리, 디스크 공간과 같은 시스템 리소스를 적게 소비한다. Docker 이미지와 컨테이너 Containerization: Application을 하나의 컨테이너 단위로 구동하는 데 필요한 모든 구성 요소(라이브러리, 설정 파일, 실행 파일 등..)를 하나로 묶는다. 이러한 단위를 image라고 한다. Image: 도커가 설치되고 구동할 준비를 하고 있는 로컬 파일 시스템, 또는 repository에 저장된 하나의 정적인 단위. Image를 파일시스템에 저장하면 tarb4all(tar.gz) 파일 형태로 저장된다. Container: Docker Image를 구동한 instance를 의미한다. Docker command Docker 구성 요소에 대한 정보 조회 docker version: Docker의 버전 정보 docker info: Docker를 구동하는 시스템에 대한 정보 docker comand: Docker command에서 사용할 수 있는 subcommand와 option을 보여준다. docker history: Image에 대한 히스토리 정보를 보여준다. 실행 중인 Container 다루기 docker ps: 현재 실행 중인 container list를 보여준다. -a: 모든 container의 상태를 보여준다. docker attach: 실행 중인 cantainer에 다른 command를 붙인다. docker exec: 현재 실행 중인 컨테이너에서 command를 실행한다. docker inspect: container의 metadata를 본다. docker cp: container에 있는 파일을 호스트 시스템으로 복사 docker diff: container를 구동한 후에 컨테이너의 파일시스템에서 변경된 사항을 확인 Image 다루기 docker images: 시스템에 있는 image 리스트를 보여준다. docker run: image를 실행한다. -rm: 프로세스가 종료되면 컨테이너 자동 삭제 -it: container 내부에 들어가기 위해 bash 키보드 입력 설정 추가 /bin/bash: bash쉘 실행 docker run --rm -it &amp;lt;image_name&amp;gt; /bin/bash docker pull: 레지스트리에서 image를 가져온다. docker pull ubuntu:latest docker push: 레지스트리에 image를 올린다. docker load: 로컬 시스템에 tarball 형태로 존재하는 image를 불러온다. docker export: container의 파일시스템을 로컬 시스템에 tarball 형태로 내보낸다. Docker 레지스트리 다루기 docker search: 레지스트리에서 이미지를 검색한다.(자신의 계정에 image를 올리거나 가져올 때) docker login: 도커 허브 레지스트리 로그인 docker logout: 도커 허브 레지스트리 로그아웃 기존 이미지 수정하기 docker tag: image에 이름을 붙인다. docker rename: image의 이름을 변경한다. container 상태 변경하기 docker pause: 실행 중인 container 일시 정지 docker unpause: 일시 정지한 이미지를 다시 시작 docker kill: container에게 kill 신호를 보냄 docker restart: container를 멈췄다가 다시 시작 docker 상태 관찰하기 docker events: 도커 서버에서 발생한 이벤트 확인 docker top: container의 프로세스 현황 확인 docker logs: container에서 생성한 로그 메시지 확인 docker stats: container에 대한 CPU 및 메모리 사용량 확인 docker wait: container가 멈출 때까지 관찰하며 container의 종료 코드를 화면에 표시 Image나 container 생성하기 docker build: Image를 새로 생성 -t: image name을 붙임 dockerfile이 같은 폴더 내에 위치할 경우 docker build -t &amp;lt;image_name&amp;gt; ./ docker rmi: Image를 제거 docker rmi &amp;lt;image_name&amp;gt; none으로 지정된 이름을 제거하기 위해 docker rmi $(docker images -a|grep &quot;&amp;lt;none&amp;gt;&quot;|awk '{print $3}') 자주 사용하는 옵션 d: detached mode, 백그라운드 모드 p: 호스트와 container의 포트를 연결(포워딩) v: 호스트와 container의 디렉토리를 연결(마운트) e: container 내에서 사용 할 환경변수 설정 name: container 이름 설정 rm: 프로세스 종료 시 container 자동 삭제 it: 터미널 입력을 위한 옵션 link: container 연결</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">딥러닝 공부 기초</title>
      
      
      <link href="http://localhost:4000/2018/12/23/DeepLearningBasic/" rel="alternate" type="text/html" title="딥러닝 공부 기초" />
      
      <published>2018-12-23T14:00:00+00:00</published>
      <updated>2018-12-23T14:00:00+00:00</updated>
      <id>http://localhost:4000/2018/12/23/DeepLearningBasic</id>
      <content type="html" xml:base="http://localhost:4000/2018/12/23/DeepLearningBasic/">&lt;h4&gt;Deep Learning from Scratch(밑바닥부터 시작하는 딥러닝), Saito koki, 한빛미디어&lt;/h4&gt;
&lt;hr /&gt;

&lt;p&gt;Chapter 1, 2 : 생략&lt;br /&gt;
Chapter 3 : &lt;a href=&quot;https://github.com/pirunita/DeepLearningBasic/blob/master/Chapter%203.%20Neural%20Network.ipynb&quot;&gt;[click]&lt;/a&gt;&lt;br /&gt;
Chapter 4 : &lt;a href=&quot;https://github.com/pirunita/DeepLearningBasic/blob/master/Chapter%204.%20Neural%20Network%20Training.ipynb&quot;&gt;[click]&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="DeepLearning" />
      

      
        <summary type="html">Deep Learning from Scratch(밑바닥부터 시작하는 딥러닝), Saito koki, 한빛미디어 Chapter 1, 2 : 생략 Chapter 3 : [click] Chapter 4 : [click]</summary>
      

      
      
    </entry>
  
  
  
    <entry xml:lang="ko">
      
      <title type="html">Category test</title>
      
      
      <link href="http://localhost:4000/2018/12/06/category-test/" rel="alternate" type="text/html" title="Category test" />
      
      <published>2018-12-06T18:07:17+00:00</published>
      <updated>2018-12-06T18:07:17+00:00</updated>
      <id>http://localhost:4000/2018/12/06/category%20test</id>
      <content type="html" xml:base="http://localhost:4000/2018/12/06/category-test/">&lt;p&gt;category test
카테고리 테스트입니다.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>pirunita</name>
          
          
        </author>
      

      

      
        <category term="DeepLearning" />
      

      
        <summary type="html">category test 카테고리 테스트입니다.</summary>
      

      
      
    </entry>
  
  
</feed>
